{"meta":{"title":"Oreo","subtitle":"Oh Oreo Blog","description":"常州大学开源软件协会博客","author":"常州大学开源软件协会","url":"https://oreo.moe/blog","root":"/home-legacy/blog/"},"pages":[{"title":"关于","date":"2020-05-26T16:37:36.000Z","updated":"2020-05-26T17:24:45.017Z","comments":true,"path":"about/index.html","permalink":"https://oreo.moe/home-legacy/blog/about/index.html","excerpt":"","text":"Project Oreo Project Oreo 是常州大学开源软件协会（CCZU OSA）主导的一系列开源、分享计划，主要由社区、校内组织（电脑 120、计算机协会、ACM 队）成员维护。 开源软件协会 中文: 开源软件协会 英文: Open Source Association 简称: OSA 目前的活动 Linux Install Party 每周小聚 社区维护 Linux Install Party: 手把手带着参与者安装 Linux，并进行最基本的使用。每学期一到两次。 每周小聚: 进行类似于小讲座形式的技术分享，但不那么正式，每两周进行一次。 社区维护: 对已上线的社区进行维护。目前，我们会定期更新博客与网盘的内容。内容更新方向分为如下两类：一是解决部分通用的师生可能会遇到的计算机相关的问题；二是分享特定软件、硬件、相关技术的经验总结。"}],"posts":[{"title":"USB科普","slug":"技术-硬件相关__USB科普__Lxy__2020-5-30","date":"2020-05-29T16:00:00.000Z","updated":"2020-05-29T16:00:00.000Z","comments":true,"path":"技术/硬件相关/USB科普@Lxy/","link":"","permalink":"https://oreo.moe/home-legacy/blog/%E6%8A%80%E6%9C%AF/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/USB%E7%A7%91%E6%99%AE@Lxy/","excerpt":"","text":"开头 USB，全称unicersal serial bus（通用串行总线），可谓平时最常用的一种接口，手机，pc，mac，键鼠，各种常见的，不常见的设备都离不开usb，usb有着各种优点，链接速度快，使用方便，支持热插拔，以及强大的向下兼容性。USB也有着各类的形态和协议，在日常使用中，又如何判断自己需要什么样的USB呢 传输协议 协议决定了usb的速度上限，usb诞生于1994年，到1996年才正式推出usb1.0，速度仅仅只有1.5Mbps，也就是理论187kb/s。两年后又推出了USB1.1，速度翻了数倍到了12Mbps（约1.5mb/s）。之后来到了2000年，推出了USB2.0，速度直接达到了480Mbps（60mb/s），这个速度即使放到20年后的今天，很多情况下也是够用的。这也就是为什么usb2.0依旧是最常见的。时隔8年后到2008年，USB3.0才姗姗来迟，速度提升到了5Gbps（625mb/s）。2013年推出了USB3.1，速度翻倍到10Gbps，2017年推出USB3.2，速度再次翻倍至20Gbps，2019年推出USB4，速度依旧翻倍至40Gbps。USB3.2和USB4目前并未普及，大部分设备还是用着USB2.0，对速度有需求的一般USB3.0就够用了，USB3.1接口也只有中高端笔记本和电脑主板才会有。 物理形态 形态决定了一个USB接口的外观，为了应对不同设备的需求，USB也需要不同的形态，USB1.0到2.0时代，接口形状有很多，有Type-A，Mini-A，Micro-A，Type-B，Mini-B，Micro-B，最常见的应该是Type-A和Micro-B了。它们基本有着4个或5个触点，两个用于供电，两个用于传输数据。到了USB3.0时代，为了能够支撑大量的数据传输，必须增加5个触点，以上的接口有的被淘汰，而有的则进化了，Type-A和Type-B在外观大体不变的情况下在内部增加了触点，而MIcro-B则简单粗暴的直接在边上加了一排接口。 这种设计的优点便是优秀的向下兼容性，以前的老线材依旧可以使用新接口，减少了换代成本，这也是USB普及的重要原因。发布USB3.1时，也推出了新的USB Type-C接口，这值得单独拎出来讨论。 如果依旧有些迷糊的话可以配合下图使用 usb.png USB.png 速度判断 那么，一个USB设备，要判断其速度，首先要确定其协议，不单要识别你的主机上接口的协议，还要确定你使用的线材，和USB设备支持的协议，只有三者都支持USB3.0或以上的协议，才能真正使用USB3.0协议。 但是，实际上，正如上文所说，协议决定了速度的上限，实际的速度受各种因素的影响，拿一个USB3.0的U盘来举例，几乎所有卖家都会宣传USB3.0的5Gbps的超高速度，但实际上U盘的闪存颗粒的质量根本无法填满USB3.0的速度，低容量的U盘在写入时的速度甚至无法达到USB2.0的上限，厂家一般只会宣传最高读取速度。 表面 实际 这就涉及到闪存的存储原理以及固体硬盘的相关知识了（下期笔者会写相关科普）。总之实际速度就是短板效应，取决于最慢的那一个，不要盲目相信卖家的宣传。 面向未来 Type-C接口有望在未来统一所有USB设备的接口，Tpye-C接口提供了24根线，能提供40Gbps的带宽，支持USB2.0以上的协议，此外还支持QC，PD快充协议，以及DP显示协议，可以直接外接显示器，还有强大的雷电3协议。Type-C体积小巧，支持正反插，这正是手机设计的需求，因此几乎所有手机都采用了Type-C接口。其强大的性能也让其成为苹果高端笔记本MacBook Pro系列的唯一接口。 迈克尔破.jpg 命名混乱 上文科普USB协议时，用了USB3.0，USB3.1，USB3.2的名称。实际上这种命名并不官方，在推出USB3.0时它确实叫USB3.0，到下一代时，官方命名实际是USB3.1 gen2，并且把原来的USB3.0改成了USB3.1 gen1。也就是说商家在宣传时完全可以把普通的USB3.0说成3.1，从而误导消费者，因此选购时要多加注意后缀。再到下一代时，也不是单纯的叫USB3.2，而是叫USB3.2 gen2x2，并且把USB3.1 gen1改成了USB3.2 gen1，还把USB3.1 gen2改成了USB3.2 gen2。其命名十分混乱。 最后推荐一个USB发展史的科普视频。 作者：活鱼君","categories":[{"name":"技术","slug":"技术","permalink":"https://oreo.moe/home-legacy/blog/categories/%E6%8A%80%E6%9C%AF/"},{"name":"硬件相关","slug":"技术/硬件相关","permalink":"https://oreo.moe/home-legacy/blog/categories/%E6%8A%80%E6%9C%AF/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/"}],"tags":[],"author":"Lxy"},{"title":"codeblocks 配置C&C++开发环境","slug":"软件-配置教程__codeblocks 配置C&C++开发环境__yulaw_k__2020-05-29","date":"2020-05-28T16:00:00.000Z","updated":"2020-05-28T16:00:00.000Z","comments":true,"path":"软件/配置教程/codeblocks 配置C&C++开发环境@yulaw_k/","link":"","permalink":"https://oreo.moe/home-legacy/blog/%E8%BD%AF%E4%BB%B6/%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/codeblocks%20%E9%85%8D%E7%BD%AEC&C++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83@yulaw_k/","excerpt":"","text":"简要介绍 此教程主要带领编程小白初步走进C语言大门（windows环境下）。 codeblocks初步了解 Code:: Blocks 是一个开放源码的全功能的跨平台C/C++集成开发环境(IDE)。 支持C语言的IDE： VS、Qt Creator、Dev C++、Code:: Blocks、X Code、Eclipse、YCM+Vim、Atom、Sublime、VS Code、KDevelop等。 这里小编将用codeblocks作为IDE来搭建C语言开发环境。codeblocks相比其他C语言的IDE，使用人数多，是目前应用较为广泛的C/C++编译软件，兼容Windows、Linux、Mac OS X操作系统。（并且是我校ACM算法设计竞赛林老师指定推荐的IDE）。 codeblocks的下载及安装 访问codeblocks官网即可免费下载安装包 http://www.codeblocks.org/ 点击Downloads, 推荐下载自带 TDM-GCC 编译器的 codeblocks-17.12mingw-setup.exe 安装包。 运行安装包 .exe 即可进入安装界面。按照界面的提示信息一步一步操作。 codeblocks的环境设置 cb1 点击 Settings 下拉菜单的 Compiler , 即可进入编译器设置界面。Codeblocks支持多种C语言编译器，而 codeblocks-17.12mingw-setup.exe 则自带了GCC编译器，不需要额外配置。 cb2 点击 Settings 下拉菜单的 Debugger , 即可进入调试器设置界面。配置调试器时，须将安装目录下的调试器路径写入界面上方的 Executable path 。 C语言上机实践和开发环境介绍 建立工程及文件 Codeblocks工程可方便代码的管理，并且可用于保存程序的相关配置信息。 编译运行程序 Codeblocks将程序的编译链接整合在一起，操作简洁，只需点击两个图标即可完成编译以及运行。 调试程序 Codeblocks具有完善的调试功能，操作指令完备并且详细。 建立工作目录 在建立工程前，我们需要先建立一个工作目录，即空文件夹，用于保存用户自己的源文件和相关的管理工程。本例将工作目录的路径设置为 E:\\codeblocks 建立工程步骤 Step 1: 点击 File ，在下拉菜单中点击 New , 在右侧弹出菜单中点击 project ，即进入建立工程的界面。 cb2 Step 2: 在选择工程模板的界面，点击 Console application , 选择控制台应用程序，在接下来的界面中，编程语言选择想要的C/C++语言。 cb2 cb2 Step 3: 输入工作目录以及工程名，点击 next ，接下来选择 GNU GCC Compiler 作为编译器，点击 finish 即工程建立完成。 cb2 保存及打开工程的步骤 点击 File ，在下拉菜单中点击 Save project as.. ，选择要保存的文件夹的位置，也可用 ctrl + s 直接保存源文件的代码。 点击 File ，在下拉菜单中点击 Open , 选择要打开的 .cbp 格式的文件，并打开。也可从文件中找到 .c 、 .cbp 、 .cpp 格式的文件，打开方式选择codeblocks从而打开。 编译运行程序 工程及源文件建立后，需要编译链接生成可执行文件，其都有对应的按钮。点击菜单栏黄色的 齿轮 按钮，则完成编译链接，绿色的三角按钮则完成运行操作。 cb7 编译错误 出现编译错误时，在Codeblocks下方的信息栏会提示报错信息，通过报错信息可以定位错误。 单击第一个报错信息，则会定位到代码出错的位置。 总结 本讲我们介绍了如何在Codeblocks环境下编写C语言程序，Codeblocks具有良好的跨平台性能，强大的代码调试能力，熟练使用Codeblocks，将有助于我们更好的学习C语言，提高我们编写以及调试程序的能力。 参考 MOOC《华中科技大学C语言程序设计》","categories":[{"name":"软件","slug":"软件","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"配置教程","slug":"软件/配置教程","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"}],"tags":[],"author":"yulaw_k"},{"title":"你真的打开了潘多拉魔盒吗？Chrome 插件推荐大众篇","slug":"软件-资源分享__你真的打开了潘多拉魔盒吗？Chrome 插件推荐大众篇__ShanRen__2020-05-26","date":"2020-05-25T16:00:00.000Z","updated":"2020-05-25T16:00:00.000Z","comments":true,"path":"软件/资源分享/chrome-plugin-share@ShanRen/","link":"","permalink":"https://oreo.moe/home-legacy/blog/%E8%BD%AF%E4%BB%B6/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/chrome-plugin-share@ShanRen/","excerpt":"","text":"前言 众所周知，chrome浏览器是当前最好用的浏览器之一。而使chrome能如此受欢迎的原因之一便是它丰富好用的插件，可以说chrome插件，正是一个欲望之盒————潘多拉魔盒，一旦打开，事半功倍，真让人欲罢不能。可惜的是，很多人使用chrome而不使用chrome插件简直暴殄天物。因此我整理了一些我认为使用Chrome必备的神级插件，数量不多，但每个都好用到爆，持续更新~~~ So，各位是否真的打开了魔盒？或者说正确的打开了魔盒？让我来为各位介绍一些好玩有用的插件吧。 进入google网上应用商店（纯小白） 对于从未用过chrome的人来说，找到google网上应用商店可能是个困难，所以简单叙述一下。 进入google网上应用商店方法：打开chrome浏览器，右上角点击“应用”，第一个图标就是google网上应用商店。 温馨提示：进入google网上应用商店需要科学上网。 注：当然不会科学上网也木有关系，前人早就想好了这种蛋疼的问题解决办法，虽然有点鸡肋，但还是解决了不少问题。 那就是谷歌助手 tPwC38.png 谷歌助手 具体的资源网上都有，由于这个有关资源的链接经常失效，正版盗版的版权问题也导致这个插件正版地址难以分辨，这里就不贴出来了，望各位上网找最新版。 这个是其中的教程，激活成功后只能用google系的服务，由于没有科学上网，google搜到的外网依然无法打开。 如果想要正常体验，还是建议各位学会科学上网。 https://zhuanlan.zhihu.com/p/105737656 众人皆爱 这边仅提供链接和图标，演示图例还请进入商店自行浏览。 我这点微薄技术没法做优质的图例让大家体验变差，真的不好意思。すみません！！！ 1. Infinity New Tab（标签页美化工具） tPw99f.png https://chrome.google.com/webstore/detail/infinity-new-tab-producti/dbfmnekepjoapopniengjbcpnbljalfg?utm_source=chrome-ntp-icon 标签页美化工具，颜值党的首选，即下即用，简单方便 点击右上角“+”号，打开自定义页面； 其中网页支持自定义，还带有足够的壁纸库，比原来google自带的多不少。 标签页的布局、字体，搜索框的形状、大小，都自定义调整，真正的随心所欲。 tPwkuQ.png 2. IE Tab（兼容问题） tPdzNt.png https://chrome.google.com/webstore/detail/ie-tab/hehijbfgiekmjfkfjpbkbammjbdenadd?utm_source=chrome-ntp-icon 这个主要是兼容问题，各位一定有过chrome打不开某些网站，而IE却能轻易打开的吧。主要是网站就是基于IE内核做出来的，也就不能支持chrome。而这个插件有效的解决了这个问题，即下即用，无需设置，是居家办公不二之选。 （windows免费，但是mac上效果不佳，而且收费，望小伙伴谨慎选择） 3. Adblock Plus（广告拦截插件） tPdjHA.png https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb?utm_source=chrome-ntp-icon 喜闻乐见的广告拦截插件， well you know，广告拦截插件那是一个满天繁星，我就选取了最有名的一个，效果不错。 Adblock Plus 你还为满屏一刀999而苦恼吗？还为片头的澳门赌场而焦虑吗？有了它，让你重回干净和谐网络环境。 没错，Adblock Plus，集众多广告屏蔽功能于一身的大成者。为广大用户打开了理想大门，即下即用，傻瓜式操作，屏蔽广告，原文会自动填充那些广告空白区，基本无违和感，甚至可以自动跳过视频的开头广告，为非技术宅提供一站式服务，你值得拥有。 Adblock Plus可以说是Adblock的进阶版，就像Iphone10和Iphone10 plus一样，你懂的。 它可以自定义屏蔽规则，毕竟不是所有的广告，都是垃圾广告（如百度广告），还是有一些质量广告的（如谷歌广告）。比如你不想看百度广告，可以在设置中屏蔽来源自百度的广告，而你还是可以看到其他来源的广告。不过这个功能因人而异哈。 当然它还有很多其他小功能，这就请各位自行探索了 4. Linkclump（快捷多开插件） tPwS4P.png https://chrome.google.com/webstore/detail/linkclump/lfpjkncokllnfokkgpkobnkbkmelfefj?utm_source=chrome-ntp-icon 快捷多开插件 当你通过某度，看到琳琅满目的搜索结果，是否想每个都打开看看，那么Linkclump一定是你必不可少的选择。 使用方法：ctrl+z，拖动鼠标，拉开所有范围内的链接。 缺点：所有链接包括广告，某度快照什么的，注意拉取角度可以一定程度避免。 5. SimpleExtManager（插件管理插件） tPwPgS.png https://chrome.google.com/webstore/detail/simpleextmanager/kniehgiejgnnpgojkdhhjbgbllnfkfdk?utm_source=chrome-ntp-icon 插件管理插件，套娃总是要套一次滴，当插件过多时，图标又是就没有文字加图标更直观了，这个时候SimpleExtManager就有用武之地了，它把横标插件进行列表展示，并且可以管理权限，让各位脱离密集恐惧症。 为了更好的插件管理而生 毕竟效率至上 6. Toby for Chrome（效率提升工具，管理标签tab） tPBYp6.png https://chrome.google.com/webstore/detail/toby-for-chrome/hddnkoipeenegfoeaoibdmnaalmgkpip?utm_source=chrome-ntp-icon 警告！警告！ 如果你使用了这个插件你将失去普通标签页，也就意味者Infinity New Tab将无法使用，取而代之的是类似收藏夹的标签页，支持分多个组。 emmm。。。怎么说呢，是标签页+收藏的结合体。比一般的标签页+收藏要实用，虽然粉粉的，但排列一般，没有Infinity New Tab好看，收集的网页只有文字，没有图，对于长期使用习惯老便签页的人（我）比较不是很习惯。 7. Chrome Better History（历史记录优化） tPBt1K.png https://chrome.google.com/webstore/detail/chrome-better-history/aadbaagbanfijdnflkhepgjmhlpppbad 有一说一，chrome的历史记录是真的简陋，搜索方法也只有文字搜索功能，不过在chrome better history的帮助下，终于有了时间轴了，喜大普奔。 优点：轻量简单，自动配置，木有烦恼 缺点：只有一个功能：时间轴。 8. crxMouse Chrome（鼠标手势插件） tPBGfx.png https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo 鼠标手势，大家都懂，老概念了，有些浏览器还是自带鼠标手势，相信不少人早就体会到了鼠标手势的妙处了。 关于这个插件，可以说样样俱到，没有太好的点，不顾也没有什么大缺点。作为一个轻度辅助工具是完全足够的了，如果各位不是完美主义者，这个完全ok的。 9. OneTab Plus（标签效率管理扩展） tPwijg.png https://chrome.google.com/webstore/detail/onetab-plustab-manage-pro/lepdjbhbkpfenckechpdfohdmkhogojf?utm_source=chrome-ntp-icon 在用Linkclump打开诸多标签页后，肯定很占内存，而这就很大程度上缓解了“内存杀手”chrome的问题，将所有页面缩入一个管理页，支持分组，支持历史组，功能健全。 缺点：和大多数此类管理插件，收入管理页后会打开就相当于重新加载，所以注意在线播放的网页。 10. 翻译类 达达划词翻译 tPB8t1.png https://chrome.google.com/webstore/detail/%E8%BE%BE%E8%BE%BE%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cajhcjfcodjoalmhjekljnfkgjlkeajl 彩云小译 tPB3kR.png https://chrome.google.com/webstore/detail/lingocloud-web-translatio/jmpepeebcbihafjjadogphmbgiffiajh 这两个翻译还是不错的（后一个有广告）不过翻译插件还有很多，都可以参照一下。 Grammarly for Chrome tPdxAI.png https://chrome.google.com/webstore/detail/grammarly-for-chrome/kbfnbcaeplbcioakkpcpgfkobkghlhen?utm_source=chrome-ntp-icon 英语语法纠错插件，效果不错的，可以用于诸多场合（你懂的。） 首次写文章，不喜勿喷，之后还会更新的（大概）","categories":[{"name":"软件","slug":"软件","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"资源分享","slug":"软件/资源分享","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Chrome插件","slug":"Chrome插件","permalink":"https://oreo.moe/home-legacy/blog/tags/Chrome%E6%8F%92%E4%BB%B6/"},{"name":"Chrome","slug":"Chrome","permalink":"https://oreo.moe/home-legacy/blog/tags/Chrome/"}],"author":"ShanRen"},{"title":"校园宽带与路由器","slug":"通用-校园__校园宽带与路由器__Teasure__2020-05-21","date":"2020-05-20T16:00:00.000Z","updated":"2020-05-20T16:00:00.000Z","comments":true,"path":"通用/校园/校园宽带与路由器@Teasure/","link":"","permalink":"https://oreo.moe/home-legacy/blog/%E9%80%9A%E7%94%A8/%E6%A0%A1%E5%9B%AD/%E6%A0%A1%E5%9B%AD%E5%AE%BD%E5%B8%A6%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%99%A8@Teasure/","excerpt":"","text":"准备 一张校园手机卡 任意路由器 宿舍网口可以正常使用 网线 此教程为不太了解的电脑的小白所写，可能稍有啰嗦。。。 步骤 下载拨号账号获取助手，输入手机号，获取自己的internet的账号。 安装路由器，用网线将网口与路由器的wan口相连接(路由器接口下面有小字标注wan口) 打开电脑 wifi，搜索路由器默认wifi名(路由器背面铭牌有写)，连接 wifi 网络，第一次使用路由器一般不用输入密码。 打开电脑浏览器，输入路由器背面铭牌的网关ip地址( 一般是192.168.1.1 )，进入网关配置界面。(一般新路由器会自动弹出此界面) 输入账户与密码，两者一般默认为 admin 与 admin。 设置上网方式，进入高级设置中的 WAN 口设置。请选择PPPOE拨号，账号为第一步所获取的账号，密码默认为666888。后续修改密码可自行登录掌上移动营业厅进行修改。 最后 至此，路由器已安装完成。若有同学深受宽带上网助手所扰，可在电脑中的 设置 -&gt; 网络和 Internet -&gt; 拨号中按照上诉步骤进行宽带设置。之后便可以自行拨号上网，无需使用宽带上网助手。 /// /// 相关软件 拨号账号获取助手","categories":[{"name":"通用","slug":"通用","permalink":"https://oreo.moe/home-legacy/blog/categories/%E9%80%9A%E7%94%A8/"},{"name":"校园","slug":"通用/校园","permalink":"https://oreo.moe/home-legacy/blog/categories/%E9%80%9A%E7%94%A8/%E6%A0%A1%E5%9B%AD/"}],"tags":[{"name":"校园宽带","slug":"校园宽带","permalink":"https://oreo.moe/home-legacy/blog/tags/%E6%A0%A1%E5%9B%AD%E5%AE%BD%E5%B8%A6/"},{"name":"路由器拨号","slug":"路由器拨号","permalink":"https://oreo.moe/home-legacy/blog/tags/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%8B%A8%E5%8F%B7/"}],"author":"Teasure"},{"title":"Microsoft Store 访问加速教程","slug":"软件-运行错误__Microsoft Store 访问加速教程__HoganTR__2020-05-12","date":"2020-05-11T16:00:00.000Z","updated":"2020-05-11T16:00:00.000Z","comments":true,"path":"软件/运行错误/Microsoft Store 访问加速教程@HoganTR/","link":"","permalink":"https://oreo.moe/home-legacy/blog/%E8%BD%AF%E4%BB%B6/%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/Microsoft%20Store%20%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F%E6%95%99%E7%A8%8B@HoganTR/","excerpt":"","text":"error wait 相信很多用着 win 10 的朋友都有碰到过类似的情况——打开 Microsoft Store ，等它转了很多圈以后，结果只看到上面这样的提醒。没关系，这篇文章将带你彻底解决它。 一些误解 微软的这些服务为什么会经常抽风呢？ 有些人可能会认为，是中国的防火墙（GFW）把微软给 ban 了。其实不然，GFW 是黑名单制，并不可能出现一会儿可用一会儿不可用的情况。所以，真正的原因还是微软的服务器不在国内，每次的访问请求都可能会飘洋过海，有时彻底失联。 那国内那些微软的服务器难道就没用？ 当然有用，但是它提供的可能是其他的服务，这部分是由中国大陆的公司独立运营的，与我们现在需求的并没有关系。对此，微软为了改善国内用户的使用体验，确实用上了 CDN，但...真的不给力，运气好解析到大陆的能够秒访问，运气不好那就真 gg 了...对此下面也提到了可能的解决办法。 主要解决 问题排除 有时候，出问题不一定是外部的原因，更可能是自己的问题。所以，我从微软社区收集了以下简单的错误解决，可以先行依次尝试。完成这些操作，很有可能你的问题已经得到了解决！ 按 Win + R 打开 「运行」——输入「wsreset」回车——等待，不要关闭 打开IE浏览器（注意不是Edge）—— 点击右上角的「设置」——点击「Internet选项」—— 选择顶部「高级」选项卡 —— 在「使用 TLS1.2」前面打上勾 进入 Windows 设置——点击「网络和 Internet」——点击左下角「代理」——将「自动检测设置」 「使用设置脚本」「使用代理服务器」至于关闭状态 修改 Host 由于复杂的网络环境， DNS 给我们分配的很可能是低速 CDN IP。这里我们可以利用 Usbeam Hosts Editor 工具来快捷修改系统 Hosts 文件，将服务指向效果最佳的 IP 地址。 软件下载：UsbEAm Hosts Editor v3.50，并解压 打开软件，点击左下角图标——选择「Microsoft Store - 微软商店」——选择需要的规则 点击「延迟检测」——选择合适的 IP（延迟低不一定速度快，可尝试多个不同 IP ）——应用选中 此时对于部分用户应该已经能够正常使用 Microsoft Store了，不过这种方法不能保证百分之百的有效性。 （若依然无效，可尝试点击“清除当前”，根据玄学测试，在部分情景下确实有奇效(。﹏。) 高阶玩家 “既然国内访问那么麻烦，那开代理总行了吧”。这确实是个不错的选择，不过因j为 Microsoft Store 属于 UWP 应用，运行在 App Container 的虚拟沙箱环境里，虽然安全性和纯进度远高于传统的 exe 应用，但是这也致使 UWP 无法使用本地的代理服务，即使电脑开启了代理的全局模式。 方式一：CheckNetisolation命令行工具 此工具是 Win 10 自带的，无需额外安装，但需较多操作 通过注册表获取 Microsoft Store 应用的 SID 通过 Win + R 快捷键打开 「运行」窗口，输入「Regedit」打开注册表编辑器，然后逐级定位到HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings，注册表编辑器左侧列出来已安装应用的 SID 值命名的文件夹，右边 DisplayName 项就是应用名称，我们这里需要找的是 DisplayName 以 Microsoft.WindowsStore 开头的应用，复制左侧对应的 SID 值。 打开 CMD 面板 通过同样操作打开「运行」窗口，输入「cmd」打开 CMD 面板 在终端输入 CheckNetIsolation.exe loopbackexempt -a -p=SID，其中 SID 用刚刚复制的值进行替换 此时再次打开 Microsoft Store，你就已经 UWP 的解除网络限制，可以通过电脑代理进行访问，加快速度了。 方式二：网络调试工具 Fiddler 如果你觉得上面的方法太麻烦，你可以下载第三方免费网络 Fiddler 进行修改，这种方法更加直白。 Fiddler 下载安装 这里 是 Fiddler 官网的下载链接，注意在下载前需要简单信息填写，并且国内下载速度较慢。此工具的安装并不复杂，直接根据提示操作即可。 工具使用 打开 Fiddler，从顶部菜单中选择「WinConfig」，在接下来的窗口中找到 DisplayName 为 Microsoft Store 的一项，勾选前方的框就可以了。 补充 虽然上面一直讲的都是 Microsoft Store 访问加速的问题，但这些方法的作用适用于所有 UWP 类应用（天气、邮件、Cortana等），同时上面用到的工具—— Usbeam Hosts Editor 还有更多功能，可以自行尝试。","categories":[{"name":"软件","slug":"软件","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"运行错误","slug":"软件/运行错误","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/"}],"tags":[{"name":"Microsoft","slug":"Microsoft","permalink":"https://oreo.moe/home-legacy/blog/tags/Microsoft/"},{"name":"联网","slug":"联网","permalink":"https://oreo.moe/home-legacy/blog/tags/%E8%81%94%E7%BD%91/"}],"author":"HoganTR"},{"title":"浅谈计算机二进制浮点数","slug":"技术-软件相关__浅谈计算机二进制浮点数__Chips__2020-05-11","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-10T16:00:00.000Z","comments":true,"path":"技术/软件相关/shwtlkfloat1@Chips/","link":"","permalink":"https://oreo.moe/home-legacy/blog/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/shwtlkfloat1@Chips/","excerpt":"","text":"如果方向错了，再快也白搭。 首先我们明确一点，目前所用的计算机都是基于许多统一规范而来的。这些规范可能不够完美，但一定是目前为止最为适用且优秀的。我很喜欢一本书中列出的硬件设计三大基本原则： 简单源于规整 越小越快 优秀的设计需要适宜的折中方案 为什么要说这个？因为计算机的浮点数也是基于硬件设计的。很多时候你可能会感知不到它，只认为是普通的一个非整数而已。其实，因为硬件限制，计算机浮点数只是对于一个数的有限位近似。而如何近似？这就需要按照它所遵循的规范了。 本文中，主要探讨大部分基于二进制的计算机与其 IEEE 754 标准，以及由此带来的一些容易忽视的计算问题。因为也是看完书后的一些总结，所以只是浅显地说一下，但我会尽量保证内容的正确性和可读性。如果有错误，请指出。 浮点数 简介 先来说一下什么是浮点数，这里引用维基百科相应词条的首段进行说明。 在计算机科学中，浮点（英语：floating point，缩写为FP）是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。利用浮点进行运算，称为浮点计算，这种运算通常伴随着因为无法精确表示而进行的近似或舍入。 -维基百科 规格化数 大家应该都很熟悉十进制中的科学计数法，比如 \\(0.0314*10^2\\)。那再进一步，一个采用科学计数法表示的数，如果没有前导 0，且小数点左边只有一位整数，则可称为规格化数。比如 \\(1.0_{10}*10^2\\) 是规格化的科学计数法数，但 \\(0.1_{10}*10^2\\)、\\(10_{10}*10^2\\) 并不是。 在二进制数中，同样如此。只不过数字并非 0-9，而是 1 或 0。比如 \\(1.0101_{2}*2^2\\) 就是一个规格化的二进制数。 浮点表示（IEEE 754） 以下会用十进制数 \\(5.25_{10}=1.0101_{2}*2^2\\) 转换为标准单精度二进制浮点数作为例子。 目前计算机表示二进制浮点数的规范，是国际通用的 IEEE 754 标准。为了说明方便，这里只涉及单精度和双精度浮点数。 IEEE 754 标准规定，任意一个二进制浮点数可规范表示为如下格式： \\[(-1)^S*F*2^E\\] S (sign): 符号表示 F (fraction): 尾数（有效数） E (exponent): 指数 它在硬件中如下表示（存储）： 490px-General_floating_point_frac.svg 你们也许发现了，这格式就如上述的规格化二进制数。其实，就是如此。在 \\(1.0101_{2}*2^2\\) 中，\\(S=0_2\\), \\(F=1.0101_2\\), \\(E=2_{10}\\)。你们也许会好奇，为什么这里 E 用十进制标出？别急，我们一步步来。我们目前仅可确定 sign 的值。 IEEE 754_1 可以看出，S 表示正负，F 的长短确定数的精度，E 的长短确定数的范围。 单精度与双精度 其主要区别在于，单精度用 32 位来表示一个二进制浮点数，而双精度为 64 位。并且，相应的尾数、指数位数会有不同。单精度中， sign 1 位， exponent 8 位， fraction 23 位；双精度中， sign 1 位， exponent 11 位， fraction 52 位。 说到位数，就不得不说 IEEE 754 对指数和尾数的特殊规定了。 指数与偏阶 其实很多你认为理所当然的东西充满着设计者的思考。 之所以将符号 sign 、指数 exponent 放最面，一个原因是，可以比较容易地处理整数比较。但 exponent 是一个无符号整数（unsigned int），那问题来了，负数如何表示才能让其更好地满足这一点？ 如果指数 exponent 用补码表示，那 -1 将会是 11111111 ，而 1 只是 00000001 。在相同符号下，这样子并不能将一个大数和一个小数快速区分。因此希望将最小负数的指数表示为最小，最大整数的表示为最大。就这样，IEEE 754 规定其指数部分采用带偏阶的计数法，即移码。 简单来说，指数 exponent 的值须减去一个中间数（偏阶），才可得到真实值。对于单精度（取值范围为 0-255），这个中间数为 127；对于双精度（取值范围为 0-2047）则为 1023。 也就是说，如要将 \\(1.0101_{2}*2^2\\) 中的指数 \\(2_{10}\\) 表示为合理的二进制指数形式，应将其加上偏阶后再转换为二进制。即 \\(2_{10}+127_{10}=129_{10}\\)，所以为 10000001 。 IEEE 754_2 至此，我们可以将之前的公式再次细化为： \\[(-1)^S*F*2^{(Exponent-Bias)}\\] 尾数与有效数 IEEE 754 标准为最大化表示数，将规格化二进制数中的前导 1 隐藏了。因此，单精度下，尾数的实际范围为 24 位，双精度为 53 位。为了说明准确，将隐藏前导 1 的尾数称为有效数（但本文中依然称之为尾数）。 为什么这样可行呢？因为用规格化二进制表示的 F，其只会在 1≤F&lt;2 之间。因此，必定存在前导 1，也就可以默认隐藏。 比如 \\(1.0101_{2}*2^{10000001}\\) 中的 F=1.0101 ，在此规定下，只需将 0101 记录在 fraction 中即可。至此转换完毕，依次对应填入即可。 IEEE 754_3 因此，最终公式可拓展成： \\[(-1)^S*(1+F)*2^{(Exponent-Bias)}\\] 特殊 那可能会有疑问了，如果是 0 的话，那岂不是也会被默认加上 1 导致无法表示？这大可不用担心，因为 IEEE 754 还有个特点，即用特殊表示特殊。简单可总结为： E 不全为 0 或不全为 1：这时，浮点数就遵守上述规则 E 全为 0（最小）：这时，若 F' 也为 0，则表示 0；若 F '不为 0，则表示非规格化数 E 全为 1（最大）：这时，若 F' 也为 0，则表示无穷；若 F' 不为 0，则表示 NaN（非数） 总结 至此，IEEE 754 规范下的二进制浮点数表示的基本规则已经全部阐述了。 我们来总的看一下最初的例子。 首先，十进制转换成相应的规格化的二进制数。 \\(5.25_{10}=1.0101_{2}*2^2\\) 然后，将其指数转换为相应的移码。 \\(1.0101_{2}*2^2=1.0101_2*2^{(129-127)_{10}}=1.0101_2*2^{10000001}\\) 再者，因为 IEEE 754 默认忽略前导 1，因此可去除 1。 \\(1.0101_2*2^{10000001}=.0101_2*2^{10000001}\\) 即 \\((-1)^0*(1+0.0101_2)*2^{10000001}\\) 最后，表示为标准的二进制浮点数。 即 0 10000001 01010000000000000000000 易忽视的计算问题 接下来，我们结合上面所描述的，来说说知道这些后，除了对具体设计的理解外，对我们日常有何应用。 主要是由于浮点数的非精确存储，其在计算过程中可能会引起微小的容易被忽视的问题。 下面的几个问题都是围绕计算所展开的，所以会有些相似，但还是都大致例举一下相应场景。 算数精确性 与整数不同，大部分浮点数无法表示一个具体的数，只能无限近似。为了保证其精确性，IEEE 754 还规定了如下内容： 保护位：在浮点数的中间计算中，在右边多保留的两位中的首位，用于提高舍入精度 舍入位：在浮点数的中间计算中，在右边多保留的两位中的第二位， 使浮点中间结果满足浮点格式，得到最接近的数 粘贴位：在保护位和舍入位之后，当舍入位右边的数非 0 时置 1，否则为 0 好处应该很容易看出，在数的比较、运算中都能提升其精度。 因为是近似，IEEE 754 也提供了几种舍入模式供程序员选择近似策略。 总是向上舍入（+∞） \\(1.50_{10}\\) -&gt; \\(2_{10}\\) \\(-1.50_{10}\\) -&gt; \\(-1_{10}\\) \\(2.50_{10}\\) -&gt; \\(3_{10}\\) 总是向下舍入（-∞） \\(1.50_{10}\\) -&gt; \\(1_{10}\\) \\(-1.50_{10}\\) -&gt; \\(-2_{10}\\) \\(2.50_{10}\\) -&gt; \\(2_{10}\\) 截断舍入 \\(1.50_{10}\\) -&gt; \\(1_{10}\\) \\(-1.50_{10}\\) -&gt; \\(-1_{10}\\) \\(2.50_{10}\\) -&gt; \\(2_{10}\\) 向最靠近的偶数舍入 \\(1.50_{10}\\) -&gt; \\(2_{10}\\) \\(-1.50_{10}\\) -&gt; \\(-2_{10}\\) \\(2.50_{10}\\) -&gt; \\(2_{10}\\) 这个过程一般是编译器自动帮你选择。当然，你也可以在处理过程中自行完成。 因此，在不同舍入模式下的运算结果可能有差别。不过也值得注意的是，即便是相同的舍入模式，在不同存储方式中，结果可能也可能不同。 可以看一下下面这个例子。 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; float a = (0.1 + 0.7) * 10; double b = (0.1 + 0.7) * 10; printf(\"%f\\n\", a); printf(\"%d\\n\", (int)a); printf(\"---\\n\"); printf(\"%lf\\n\", b); printf(\"%d\\n\", (int)b); return 0;&#125; 123458.0000008---8.0000007 有时需要注意。 比较问题 可以看一下这段程序： 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; double a = 1.23456789; double b = 1.23456781, c = 1.23456782; double b1 = 0.00000008, c1 = 0.00000007; double bb, cc; if (a == 1.23456789) printf(\"true1\\n\"); bb = b + b1; if (a == bb) printf(\"true2\\n\"); cc = c + c1; if (a == cc) printf(\"true3\"); return 0;&#125; 输出： 12true1true2 由此可见，第三个 if 判断为假。这也是因为其存储精度，在计算上引起的问题。 c_1 所以在比较经计算后的浮点数时，对于精度要求不高的时候，可以进行相应转换。或不要求完全相同，检测其误差是否在一定范围之内。 加法结合律 有上面的例子后，再来看看浮点数的加法/减法。 我们可以来看下面这个例子： 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; float a = 3.14e7, b = -3.14e7, c = 1.0; float aa = 150.5, bb = -150.5, cc = 0.1; printf(\"(3.14e7 + -3.14e7) + 1.0 = %f\\n\", (a + b) + c); printf(\"3.14e7 + (-3.14e7 + 1.0) = %f\\n\", a + (b + c)); printf(\"---\\n\"); printf(\"(150.5 + -150.5) + 0.1 = %f\\n\", (aa + bb) + cc); printf(\"150.5 + (-150.5 + 0.1) = %f\", aa + (bb + cc)); return 0;&#125; 输出为： 12345(3.14e7 + -3.14e7) + 1.0 &#x3D; 1.0000003.14e7 + (-3.14e7 + 1.0) &#x3D; 0.000000---(150.5 + -150.5) + 0.1 &#x3D; 0.100000150.5 + (-150.5 + 0.1) &#x3D; 0.100006 由此可以看出，浮点数加法不同的结合方式最终会有不同的结果。根本原因也很清楚，因为大部分浮点数只是一个数的近似表示，只有有限位的它，会根据舍入模式来选择性进位或舍去一些数。 但我们可以进一步抽象，问题可以归结为：浮点数计算中改变计算的顺序可能会得到不同的计算结果，即结果不可重复。 下面这个 Python 的例子，很好的说明了这一点。 1234567891011121314import randomsu1 = su2 = 0 # 数的和ar = [random.uniform(1, 1e20) for i in range(10000)] # 生成随机数# 正序相加for x in ar: su1 += x# 倒序相加for x in ar[::-1]: su2 += xprint(su1)print(su2) 输出： 125.023873624910684e+235.0238736249107135e+23 虽然在很多时候这种区别微乎其微甚至可以忽略，但在一些需要高精度或复杂计算的时候，多次运算会不断放大这种差别，最后每次都会得到不同的结果。 不过，乘法和除法是相对安全的。 并行计算 随着需求以及技术的发展，现代计算机有很多并行的场景。 现代处理器为了能同时提取并处理多个数据，通常会在一个宽字内部进行的并行操作，即子字并行。例如，在 128 位内对进位链进行分割，使处理器可同时处理 16 个 8 位、8 个 16 位等运算的同时进行并行操作。还比如操作系统层对运行程序的抽象--进程，以及其线程，都是并行的一种表现。 这必然后导致一个问题，也就是上述提到的问题，浮点数计算的顺序会导致结果的不可重复。 可以看一下下面这个例子。Python 多线程间的执行顺序不同，结果也不同，原因还是与上述相同。 1234567891011121314151617181920212223242526272829303132333435363738import threadingimport randomsu1 = su2 = 0 # 数的和ar = [random.uniform(1, 1e20) for i in range(10000)] # 生成随机数lock = threading.Lock() # 线程锁status1 = [] # 线程列表status2 = [] # 线程列表def adds(num, typ): global su1, su2 lock.acquire() if typ == 1: su1 += num elif typ == 2: su2 += num lock.release()for x in ar: status1.append(threading.Thread(target=adds, args=(x, 1))) status2.append(threading.Thread(target=adds, args=(x, 2)))# 打乱执行顺序random.shuffle(status1)for x in status1: x.start()for x in status1: x.join()# 打乱执行顺序random.shuffle(status2)for x in status2: x.start()for x in status2: x.join()print(su1)print(su2) 输出： 125.0523641431462865e+235.052364143146297e+23 最后 其实关于易忽视的计算问题中，大部分都是因为存储精度引起的问题。如果对于精度要求不高，不负责任地说，选择忽视其实问题也不大... 关于这点，还有一个专门的领域来研究算法的数值稳定性，叫数值分析。 参考 《计算机组成与设计：硬件/软件接口》 https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html https://inst.eecs.berkeley.edu/~cs61c/su12/disc/Discussion6.pdf https://cs.nyu.edu/courses/spring17/CSCI-UA.0201-001/resources/lecture10.pdf","categories":[{"name":"技术","slug":"技术","permalink":"https://oreo.moe/home-legacy/blog/categories/%E6%8A%80%E6%9C%AF/"},{"name":"软件相关","slug":"技术/软件相关","permalink":"https://oreo.moe/home-legacy/blog/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"float","slug":"float","permalink":"https://oreo.moe/home-legacy/blog/tags/float/"}],"author":"Chips"},{"title":"我就不好好说话","slug":"软件-创意分享__我就不好好说话__blackusagi__2020-05-06","date":"2020-05-05T14:10:42.000Z","updated":"2020-05-05T16:00:00.000Z","comments":true,"path":"软件/创意分享/python_wjbhhsh@blackusagi/","link":"","permalink":"https://oreo.moe/home-legacy/blog/%E8%BD%AF%E4%BB%B6/%E5%88%9B%E6%84%8F%E5%88%86%E4%BA%AB/python_wjbhhsh@blackusagi/","excerpt":"","text":"python程序：我就不好好说话 0x00 序言 本人是个菜鸡，第一篇文章也不像大佬们一样有什么内容可写，就分享几行代码供大家笑话吧 该项目的灵感源自GitHub上的😩「能不能好好说话？」 拼音首字母缩写翻译工具。 虽然翻译写不出来但是转换成首字母把消息搞得乱七八糟还是可以搞的hhhhhh 当然，按照惯例，这个文件应该命名为wjbhhsh.py 话说第一篇文章就这么水会不会被会长打死(っ °Д °;)っ 0x01 直接上代码 12345678from pypinyin import pinyin, lazy_pinyin, Style # 使用pypinyin库origin = input() # 读取输入字符results = pinyin(origin, style=Style.FIRST_LETTER) # 把输入的扔给pypinyin，设定输出样式为首字母for result in results: # 打印 print(result[0], end='') 0x02 简介，细节 这里使用了库pypinyin，用以将输入的汉字转为首字母 参考pypinyin的使用例 12&gt;&gt;&gt; pinyin('中心', style=Style.FIRST_LETTER) # 设置拼音风格[['z'], ['x']] 这里应该注意函数返回的形式是嵌套的列表，所以输出时应该用result[0] 0x03 最后 这是一个很简单的python代码（虽然没什么实用价值），python里有很多很好用的库，开发起来很简单那种，还是很值得用的 最后，这第一篇文章就愉快的写水完了ο(=•ω＜=)ρ⌒☆ 参考 https://pypi.org/project/pypinyin/ https://www.runoob.com/python3/python3-list.html","categories":[{"name":"软件","slug":"软件","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"创意分享","slug":"软件/创意分享","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/%E5%88%9B%E6%84%8F%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://oreo.moe/home-legacy/blog/tags/python/"},{"name":"闲","slug":"闲","permalink":"https://oreo.moe/home-legacy/blog/tags/%E9%97%B2/"}],"author":"blackusagi"},{"title":"VS Code 配置 C&C++ 开发环境","slug":"软件-配置教程__VS Code 配置 C&C++ 开发环境__Chips__2020-05-04","date":"2020-05-03T16:00:00.000Z","updated":"2020-05-03T16:00:00.000Z","comments":true,"path":"软件/配置教程/vscode4candcpp@Chips/","link":"","permalink":"https://oreo.moe/home-legacy/blog/%E8%BD%AF%E4%BB%B6/%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/vscode4candcpp@Chips/","excerpt":"","text":"准备 此教程主要为有自己解决问题的能力且刚入门的人编写，所以会有点啰嗦。 步骤 安装编译器等 安装并配置 Visual Studio Code 在这里插一个小知识，关于文本编辑器（俗称编辑器）、编译器、集成开发环境（IDE） 的区别。因为发现很多新手并没有搞清楚这些概念，有些老师也没有特意强调。 小知识 文本编辑器 文本编辑器是计算机软件中的一种。主要用于用来编写和查看文本文件。有一些特殊的文本编辑器支持增加自有的格式来丰富文档的表现形式。操作系统或者集成开发环境通常会带有可以查看和编辑纯文本的编辑器，可增加格式的文本编辑器通常是个人用户或者公司在制作需要格式的文件中使用。 -维基百科 在编码中，简单来说可认为是你写文本的那个窗口程序。 编译器 编译器（compiler）是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）。 它主要的目的是将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序，也就是可执行文件。编译器将原始程序（source program）作为输入，翻译产生使用目标语言（target language）的等价程序。源代码一般为高级语言（High-level language），如Pascal、C、C++、C# 、Java等，而目标语言则是汇编语言或目标机器的目标代码（Object code），有时也称作机器代码（Machine code）。 一个现代编译器的主要工作流程如下： 源代码（source code）→ 预处理器（preprocessor）→ 编译器（compiler）→ 汇编程序（assembler）→ 目标代码（object code）→ 链接器（linker）→ 可执行文件（executables），最后打包好的文件就可以给电脑去判读运行了。 -维基百科 简单来说，可认为是将你写的高级语言代码翻译成机器语言代码。 集成开发环境 集成开发环境（Integrated Development Environment，简称IDE。是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 IDE通常包括编程语言编辑器、自动构建工具、通常还包括调试器。有些IDE包含编译器／解释器，如微软的Microsoft Visual Studio，有些则不包含，如Eclipse、SharpDevelop等，这些IDE是通过调用第三方编译器来实现代码的编译工作的。有时IDE还会包含版本控制系统和一些可以设计图形用户界面的工具。许多支持面向对象的现代化IDE还包括了类别浏览器、对象查看器、对象结构图。虽然当前有一些IDE支持多种编程语言（例如Eclipse、NetBeans、Microsoft Visual Studio），但是一般而言，IDE主要还是针对特定的编程语言而量身打造（例如Visual Basic）。 -维基百科 简单来说，可认为是一个同时携带了编辑器、编译器等的程序，比较便捷，但有的也很强大。大部分老师推荐的写代码的工具都属于这一类。 Visual Studio Code 我们今天主要基于 Visual Studio Code 展开教程，下面简称 VS Code。这是一款微软出品的编辑器，但因支持各种拓展插件，使其可以具备类似 IDE 功能的同时，继续保持轻量。但毕竟它本身是个编辑器，不包含编译器等功能。因此我们需要自己去配置它们，也就是我们常说的，搭建、配置开发环境。 编译器安装 这里的编译器只是统称，会同时包含调试器、汇编器等。 因为每个系统下的编译器实现不同（规范相同），所以要根据不同版本下载不同的编译器。以下列出推荐安装的，也是教程中用到的。 Windows MinGW-w64 macOS Clang GCC Linux GCC（自带） Windows 这里使用 MinGW-w64 的实现。 安装 如果再一开始出现 Cannot download reposytory.txt[0] 错误，可以尝试关闭杀毒软件（包括 Windows Defender），并以管理员方式运行。 选项相关 Version：GCC 版本，若无特殊需求优选最高 Architecture：系统架构，64 位系统选 x86_64 ，32 位选 i686 Threads：操作系统 API，开发 Windows 程序选 win32 ，开发 Linux、Unix、macOS 等其他 posix 协议的操作系统程序选 posix Exception：异常处理模型 64 位系统 seh ：性能优化好，优选 sjlj ：稳定性好 32 位系统 dwarf ：性能优化好 sjlj ：稳定性好 Build revision：修订版本，保持默认即可 添加环境变量 安装完成后，还需添加环境变量。 因为安装程序不会自动添加环境变量，所以要手动添加。为什么要添加呢？简单来说，你在终端中执行命令，命令本身很短，那系统可能分不清或根本不知道这是指什么。在这种情况下，系统会去检索环境变量目录中的文件，如果有匹配的，就执行相应程序。 打开 此电脑-属性-高级系统设置-高级-环境变量 ，在 系统变量-Path 编辑并新建你 MinGw-w64 安装目录下的 bin 文件夹路径，例如 C:\\Program Files\\mingw-w64\\xxx\\mingw64\\bin 。保存即可。 之后可以在终端（如 cmd）中输入 gcc --version ，如果有显示版本号就代表安装成功。 （额外：这里可以注意一下终端和 Shell 的关系） macOS 因为 macOS 与 Linux 类似，都属于类 UNIX 系统。所以在搭建环境这一块有天然的支持优势，大部分情况下会比 Windows 方便很多。 Clang 这是最简单的。在 App Store 中搜索 Xcode，下载安装即可。 GCC 推荐通过 Homebrew 安装，很是好用和方便。 Homebrew 这里稍稍说一下 Homebrew 是什么。 Homebrew是一款自由及开放源代码的软件包管理系统，用以简化macOS系统上的软件安装过程。 -维基百科 包管理系统可以说是 Linux 最大的优势，这里不做拓展，之后可能会写一篇文章专门讲一下。macOS 自身并没有包管理程序、社区，但作为同是类 UNIX 家族测程序，怎么可以这样的？！Homebrew 的出世解决了这个痛点。 Homebrew 基于 Ruby 语言编写，macOS 是自带的。但将来的 macOS 可能不会自带 Ruby，如果这样的话之后会更新教程以同步。（来源） 安装 Homebrew 方便起见，推荐还是先在 App Store 中安装 Xcode 再进行以下操作。 打开终端，输入以下指令即可。可能会先提示安装 Command Line Tools。 1/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" 安装 GCC 在终端中输入以下指令。 1brew install gcc 如果要安装不同版本的 GCC，可以先 brew search gcc 再 brew install xxx 安装相应版本。 好了，到此就完成了。如果有兴趣继续使用 Homebrew，可以自己查看相关文档。顺便一提，Homebrew Cask 也可以按照桌面程序。 Linux 大部分 Linux 发行版都自带 GCC，所以一般不需要自己安装。 最后 到这里你就可以编译并调试你的程序啦！不过，这所有的过程都要你手动执行。简单以下面的 hello.c 程序演示。 123456789#include &lt;stdio.h&gt;int main() &#123; printf(\"hello world!\"); getchar(); return 0;&#125; 在文件相应目录下，执行 gcc hello.c 即可。你会发现同目录下多了一个可执行文件，运行即可。 VS Code 配置 Visual Studio Code 安装很简单，就不多说了。 如果在添加环境变量之前就运行了 VS Code 的话，请先将其完全退出， 文件-退出 。否则将会识别不了新的命令。 配置 为什么要配置呢？因为 VS Code 只是一个编辑器，你必须自己指定编译器、调试任务后它才能正常工作。VS Code 有工作区的概念，可以在一个工作区内进行相应操作和配置。为了说明方便，暂时默认我们的工作区只有一个单一的文件夹。 下述示例中的配置内容是在 Windows+MinGW 下编写的。所以，在 Windows 系统中，每一步都推荐使用示例中的内容。在 macOS 和 Linux 中，一般默认可以。 Step1 首先，在 VS Code 的拓展中搜索并安装 C/C++，它提供了 C/C++ 代码补全、调试等功能。 Step2 这步是创建编译相关的配置文件，会在工作区文件夹中创建 .vscode/c_cpp_properties.json 文件。 Ctrl/Command + Shift + P ，输入 C/C++:Edit Configurations ，这里选用 JSON 编辑。 C/C++ 插件会自动检测编译器位置。所以如果编译器安装成功，输入以上命令后一般就会得到一个可用的配置文件。下面是一个示例： 1234567891011121314151617181920&#123; \"configurations\": [ &#123; \"name\": \"Win32\", \"includePath\": [ \"$&#123;workspaceFolder&#125;/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:\\\\Program Files\\\\mingw-w64\\\\xxx\\\\mingw64\\\\bin\\\\gcc.exe\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"clang-x64\" &#125; ], \"version\": 4&#125; 如果你发现 compilerPath 的程序并不是你需要的编译器，可以手动修改。 Step 3 这步是创建任务相关的配置文件，会在工作区文件夹中创建 .vscode/tasks.json 文件。 Ctrl/Command + Shift + P ，输入 Tasks: Configure Task 。 在输入上述命令后，如果有弹出类似 C/C++: gcc.exe build active file 等选项，可以直接选取，这会直接自动创建完整的调试配置文件。 当然，如果你希望要自己编辑，可以选择 使用模板创建 tasks.json 文件 。 下面是一个示例： 1234567891011121314151617181920&#123; \"version\": \"2.0.0\", \"tasks\": [ &#123; \"type\": \"shell\", \"label\": \"C/C++: gcc build active file\", \"command\": \"gcc\", \"args\": [ \"-g\", \"$&#123;file&#125;\", \"-o\", \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\" ], \"problemMatcher\": [ \"$gcc\" ], \"group\": \"build\" &#125; ]&#125; 如果需要编译 C++ 代码，请将 command 改为 g++ 。如果未添加环境变量，请将其改为编译程序的完整路径。 Step4 这步是创建调试相关的配置文件，会在工作区文件夹中创建 .vscode/launch.json 文件。 Ctrl/Command + Shift + P ，输入 Debug: Open launch.json ，选择 C++ (GDB/LLDB) ，选择 默认配置 。可以根据提示自行修改。以下是一个示例： 1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"Debug C/C++\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;workspaceFolder&#125;\", \"environment\": [], \"externalConsole\": true, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"C:\\\\Program Files\\\\mingw-w64\\\\xxx\\\\mingw64\\\\bin\\\\gdb.exe\", \"setupCommands\": [ &#123; \"description\": \"为 gdb 启用整齐打印\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true &#125; ], \"preLaunchTask\": \"C/C++: gcc build active file\", &#125; ]&#125; 请将 miDebuggerPath 改为你调试器的地址。 注意，配置文件中一定要包含 preLaunchTask 项，这是在调试之前预执行的任务。因此，此处要填写 Step3 中相应任务的 label 。 最后 至此，已经全部配置完成。 然后只需在 VS Code 左边菜单的运行中，点击左上角的绿色三角，即可开始编译并调试 C/C++ 文件。 参考 https://rsreland.net/blog/202002172024/","categories":[{"name":"软件","slug":"软件","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"配置教程","slug":"软件/配置教程","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://oreo.moe/home-legacy/blog/tags/vscode/"},{"name":"c","slug":"c","permalink":"https://oreo.moe/home-legacy/blog/tags/c/"},{"name":"c++","slug":"c","permalink":"https://oreo.moe/home-legacy/blog/tags/c/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://oreo.moe/home-legacy/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"author":"Chips"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://oreo.moe/home-legacy/blog/categories/%E6%8A%80%E6%9C%AF/"},{"name":"硬件相关","slug":"技术/硬件相关","permalink":"https://oreo.moe/home-legacy/blog/categories/%E6%8A%80%E6%9C%AF/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"软件","slug":"软件","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"配置教程","slug":"软件/配置教程","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"name":"资源分享","slug":"软件/资源分享","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"},{"name":"通用","slug":"通用","permalink":"https://oreo.moe/home-legacy/blog/categories/%E9%80%9A%E7%94%A8/"},{"name":"校园","slug":"通用/校园","permalink":"https://oreo.moe/home-legacy/blog/categories/%E9%80%9A%E7%94%A8/%E6%A0%A1%E5%9B%AD/"},{"name":"运行错误","slug":"软件/运行错误","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF/"},{"name":"软件相关","slug":"技术/软件相关","permalink":"https://oreo.moe/home-legacy/blog/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3/"},{"name":"创意分享","slug":"软件/创意分享","permalink":"https://oreo.moe/home-legacy/blog/categories/%E8%BD%AF%E4%BB%B6/%E5%88%9B%E6%84%8F%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Chrome插件","slug":"Chrome插件","permalink":"https://oreo.moe/home-legacy/blog/tags/Chrome%E6%8F%92%E4%BB%B6/"},{"name":"Chrome","slug":"Chrome","permalink":"https://oreo.moe/home-legacy/blog/tags/Chrome/"},{"name":"校园宽带","slug":"校园宽带","permalink":"https://oreo.moe/home-legacy/blog/tags/%E6%A0%A1%E5%9B%AD%E5%AE%BD%E5%B8%A6/"},{"name":"路由器拨号","slug":"路由器拨号","permalink":"https://oreo.moe/home-legacy/blog/tags/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%8B%A8%E5%8F%B7/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://oreo.moe/home-legacy/blog/tags/Microsoft/"},{"name":"联网","slug":"联网","permalink":"https://oreo.moe/home-legacy/blog/tags/%E8%81%94%E7%BD%91/"},{"name":"float","slug":"float","permalink":"https://oreo.moe/home-legacy/blog/tags/float/"},{"name":"python","slug":"python","permalink":"https://oreo.moe/home-legacy/blog/tags/python/"},{"name":"闲","slug":"闲","permalink":"https://oreo.moe/home-legacy/blog/tags/%E9%97%B2/"},{"name":"vscode","slug":"vscode","permalink":"https://oreo.moe/home-legacy/blog/tags/vscode/"},{"name":"c","slug":"c","permalink":"https://oreo.moe/home-legacy/blog/tags/c/"},{"name":"c++","slug":"c","permalink":"https://oreo.moe/home-legacy/blog/tags/c/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://oreo.moe/home-legacy/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]}